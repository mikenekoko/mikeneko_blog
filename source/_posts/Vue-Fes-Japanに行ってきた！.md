---
title: Vue Fes Japanに行ってきた！
date: 2018-11-04 20:44:37
tags:
- vue.js
- vueFesJapan
image: https://www.yumemi.co.jp/application/files/1815/3803/8559/vuefesjapan2015.png
---
<img src="https://www.yumemi.co.jp/application/files/1815/3803/8559/vuefesjapan2015.png">
お疲れ様です、みけです。
本日はVueFesJapanにやってきました！その様子を開場から追っていきたいと思います！


## タイムテーブル
[こちら](https://vuefes.jp/time-table/)に書いてある通りです。
<img src="https://qiita-image-store.s3.amazonaws.com/0/178351/4c9e046c-bb40-b9a0-63c6-3126c83c4ba0.png">

# 開場
> 9:30 ~ 10:20

<img src="https://pbs.twimg.com/media/DrCh5uTUUAEh7fA.jpg">
既に入り口付近がすごい人だかりです！
様々な企業がブースを構えています！
有名な企業だと、LINEやMicrosoftさんがいました。

---

# keynotesession
> 10:30 ~ 11:20

<img src="https://pbs.twimg.com/media/DrCuHY4V4AE0bob.jpg">
Vue.jsの生みの親であるEvan氏による、Vue.js3.0リリースの話と今までのVue.jsのお話。
英語で話されているのを、スタッフが同時翻訳するというスタイル。
詳しく書いていきます。

# Vue.js 3.0 リリースの話
* より早く
* より小さく
* よりメンテナンスしやすく
* よりネイティブ向けに作りやすく
* よりあなたのコードの保守性を向上

主な変更点は上記5つであると話されていました。

## より早く
### 仮想DOMの実装を作り直して最大化

* mountとpatch処理が最大100%に向上する

### プロキシを用いた監視の強化

* 今後は、クラスといったものも監視できるようになる

### コンパイルの仕組みを高速化

* 実行中のオーバーヘッド削減のためコンパイル時にヒントを追加(地味に嬉しい)
* コンポーネント探索の高速化
  * コンポーネントの状態をテンプレートに認識させ、子要素が存在しない場合は中身を探索しない等、無駄な処理を省き高速化を実現
* 静的ツリーを巻き上げる
  * テンプレートを静的部分と動的部分で区別して、処理を分離させる
  * Laizy Fanctionという仕組みを取り入れることにより、子要素は必要な場合のみ呼び出されることになる

### `単純に、3.0にアップデートするだけで早くなる`

* たとえば、表示に284msかかるサイトがあるとすれば、Vue3.0に上げるだけで164msにまで向上します！
* Vue2.5から3.0にすることで、メインメモリ使用量も速度も2倍レベルになる
* 特に書き換えることなく上記の最適化が行われ速度向上が見込めます！

すごいですね、Vue3.0で登場した新機能の書き方に変えれば～というわけでなくアップデートするだけで速度が向上するなんて。感激です。

## より小さく
### Tree Shakingへの対応

* 使われていないコードをバンドルされたファイルに含まないようにする機能
  * 様々な分野で使われていない部分を感知する
    * ビルドインのコンポーネント(keep-alive,transition)
    * ディレクティブのヘルパー (v-model,v-for）
    * ユティリティ関数(osyncComponent,mixins)

Tree Shakingについては[こちら](https://qiita.com/pirosikick/items/863830856891d40308cb)

### 新コアのランタイムサイズは、Gzipで10kb以下になる。

* Vueはより軽いものになる！

## よりメンテナンスしやすく

### アーキテクチャの整理

* アーキテクチャの整理を行った関係で、Javascriptが動く華僑があればどこでも実行することができます
  * それはつまり、ブラウザーがなくても開発できる環境を意味しています！

### パッケージの分離

* 状態を変更した場合、それは複数のコンポーネントに影響を与えます
* この場合にどのコンポーネントにそれを適応させたらいいのか考えてくれます。

### テストセットアップの改善


## よりネイティブ向けに作りやすく

### カスタムレンダラAPI

* カスタムレンダラAPIを使うことで、ネイティブ向けのアプリを使いやすくなります
* これは、ネイティブ向けの開発者ツールになります。

## よりあなたのコードの保守性を向上

### リアクティビティAPI

* リアクティビティAPIを使うことで、どんなコンポーネントでも監視できるようになる
  * observableメソッドでVuexのstateの変更を監視できる
  * storeを変更することですべての参照している箇所をアップデートできることができます
  * Evan「今後、Vuexは必要ないかもしれませんね」と言っていた
* リアクティブの画面に反映

### コンポーネントの再描画を理解しやすくする

* Render Trackという仕組みを導入
* デバッグをしやすくなる

### TSXによるTypeScriptサポートの強化

* TSXでRender関数を記述することができる
  * Vue2のTSのサポートはそんなにいいものではなかった

### HooksAPI

* Reactで登場した機能を導入
* コンポーネントのロジックを梱包するのが簡単になる
* mixinのネームスペースが被る問題の解決策になる
  * たとえば、5個のmixinがあった場合、どこを参照しているか非常にわかりづらい
  * Hooksを使うことで、簡単になります。管理もしやすい！
    * APIからXML形式で結果が返ってきます
    * それをMutatiosnで受け取り、3つの率い数で受け取ってそれをrender関数wに渡すだけで良くなるのです

### Time Slicing

* 重い処理があったとしても、ブロッキングしなくなる。処理を分断させる
* たとえば入力フォームに入れた内容を、バインドしてコンポーネントで読み込み表示するとします
* 入力されるたびにコンポーネントが更新され、おもくなります
* 高速でタイピングしたとして、hoge と売った場合、hog は描画するものの、最後のeが描画された瞬間に最初の3文字を描画する処理は必要なくなります。これをslicingは自動で判断し、処理をスキップします
* これにより、パフォーマンスの大幅向上が見込めるのです

処理の実行中に新しい処理のキューが溜まった場合、古い処理を捨て新しい処理に写るというもの。非常に便利そうだ。

---

# ランチブレーク

> 11:30 ~ 13:00

<blockquote class="twitter-tweet" data-lang="ja"><p lang="ja" dir="ltr">Vue Fes Japan 2018のランチセッションの弁当は人形町今半のすき焼弁当だった。 <a href="https://twitter.com/hashtag/vuefes?src=hash&amp;ref_src=twsrc%5Etfw">#vuefes</a> <a href="https://t.co/2oA60XqCeJ">pic.twitter.com/2oA60XqCeJ</a></p>&mdash; iwbjp (@iwbjp) <a href="https://twitter.com/iwbjp/status/1058548833938853888?ref_src=twsrc%5Etfw">2018年11月3日</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

本来は、ここでランチを食べながらスポンサーのセッションを聞くことができるのだが先着から外れてしまったので惜しくも外で一人で食べることに。
内容が気になる方は他の方のVueFesJapan2018のまとめ記事をどうぞ。
すき焼きおいしそうだなぁ。。。

---

# Vue.js と Web Components のこれから

> 13:00 ~ 13:40 セッション1 Bホール

<iframe class="speakerdeck-iframe" frameborder="0" src="//speakerdeck.com/player/0bf75fbec2584e69a35b067b43ddee41?" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true" style="border: 0px; background: padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 700px; height: 540px;"></iframe>

* https://vuefes.jp/speakers/takanorip/
* @takanorip
* 本出版中：イヌでもわかる web components ←調べてみる

# webcomponentsとは？
* WEBの標準技術でコンポーネントの考え方をわかるようにするもの
* CustomElements

## Custom Elements
* 独自の木野や見た目を持ったHTML要素を定義できるようにするための仕様
* 普通のVueのカスタムコンポーネント。

## shadow Dom
* DOMのカプセル化を実演するための仕様
* ShadowRoot
** - Shadow Tree
* Vueのcomponentの元となったような仕様

といった風にはいかにツリーが作成される。

## HTML template
* <template>要素を使用してHTMLドキュメントでHTMLの雛形を扱うための仕様

## ES Modules
* ES5で導入されたESMおづぇｓの機能を利用して、外部で定義されたカスタム要素を読み込む
* `2019春` にGoogleChromeから削除される予定
** ↑全く聞いたことないので調べてみる

## HTML Modules
* HTMLをJSの中に直接Importできるようする仕様
** 同時に、CSSModulesも開発されてるよ！
* またIssueで話されてるだけの段階なので、考え中

## How to build web components with vue.js?
Vue CLI 3 Build Targetsを使うと、WebコンポーネントをVueで使うことができる！
* Vue CLI 3 で build するときに、 `--target wc` というオプションを付けると、Vue.jsのコンポーネントをWeb Componentsに変換して生成される

### vue/web-component-wrapper
* Vueコンポーネントをラップしてカスタム要素として登録する

```
import wrap rom `@vue/web-component-wrapper`
```

## いつ使うの？
この機能を使うことで、Vue.jsで作ったコンポーネントを簡単にWebコンポーネントに移行できる。
* Web Component の部分的な導入にも使える

## なんでWebコンポーネントを使っていった方がいいのか？
* UIフレームワークを統一できる。JSフレームワークごとに（リアクトとかVueとか）UIフレームワークを使い分けるのは効率が悪い。
* フレームワークを変更しなくてはならなくなった場合に、UIを使いまわせる！
* 環境依存しないから、公開しやすいよ
** 一回使ってみる

### 完全にスコープである
* JSは完全なスコープではない。WebComponentsでは、Shadowを使用することでスコープな実相が可能となる。
* たとえば、大きなプロジェクトでCSSの依存関係が意味不明になっているとする。Globalな開発がしたい場合に使用できる。
* デメリットとしては、CSSの設計を大幅に見直す必要があること、外部から渡されるイベントハンドリングが面倒。

## 正直？
* Vue.jsの機能を使ってコンポーネントを作ったほうが簡素で簡単。

## じゃあなんでやるの？
Micro Frontend
1. 大きなサービスや構造、ページは細かく分けてお互いに影響を及ぼさないような設計に使用という考え方。
2. 柔軟なWebサイトを作りましょう。
  * たとえば、CSS変えるとかライブラリを変えたり、JSを変えたりとか。。簡単に変えると、アプリケーション全体が壊れてしまうということが起こりえる。
  * ここでWebComponentsならScopedなので変更が容易！
3. Vueもいつか死にます。フレームワークを使っている時点で、負債を作っているという自覚を持とう。
  * 新しいものに作り替えるとしたら？工数も莫大にかかる。Vueで書く = 負債を作り出している。
  * そこで、WebComponentsを使うことで簡単に移行することができる。
    * -> ここは弊社が抱えている問題そのものなので、積極的に取り入れていきたい。今のCatalystからVue.jsへの移行も簡単なのでは？
  * これがWeb標準である強み。 `負債を貯めない` ということに重点を置くならば、WebComponentsは有用。

# 将来どうなるの？
Vue.jsは将来的にWebComponentsに置き換えられていくの？
 -> No。絶対そんなことはない。
* どちらかというと、共通して生きていくこと。
* Vue.jsはデータバインドとか、データのやり取りで有効活用していき、WebComponentsは末端に行ってほしい。
* Web Components is to encapsulate HTML elements
  * WebComponentでアプリケーションは作れるが、そういうものじゃない。
  * HTMLなどの干渉をなくしていこうという考え方です。
  * Vue.jsはウェブアプリケーションを作るためのフレームワーク。そこは、Vue.jsでやっていきましょう。
    * *直接的に置き換わっていくものではないです！*
  * Web標準にのっかりながら、Vue.jsを使って開発をしていきましょう。

# まとめ
* WebComponentsはProduction-readyだけど、課題も多い。
* Vue.jsとWebComponentsは共存できます！
* UIをWeb Componentsに任せることで、負債を減らすことができる。
* アプリケーションサイドはVue.jsに任せることがいい。

`Let's use Web Components!`

webComponentsの話はだいたいWebサイトにまとまっています。
-> ググってみる
* よくわかるWebComponentsという本がまとまっていてオススメ！
* PolimarJapanの本もいいよ

---

> セッション2 (13:50 ~ 14:30)

# 第二セッション  A : 
* 最終的に、自分の作ったアプリケーションの話
* Vue.Designer というツールを開発中！
* デザインと、開発の実相が分離されていることに辛いと思っている実在がある。

## Webアプリ / サイト開発について
だいたい、フォトショとかでデザインして、JS/マークアップで実装みたいなことになっているんじゃないでしょうか。
-> 弊社も、Prottでデザインされたものの通りにHTML / CSSに落とし込んでいるので全く同じ。
デザイナー
* UI / 情報設計 / アクセシビリティ / スタイルガイド とか
開発者
* コード設計 / 状態管理 / レスポンシブ / アニメーションなどなど
-> 岡田とイソベみたいな関係？ OWもまさにこれ。

## デザインと実装が分かれることの問題って？
１つ勘違いしないでほしいのは、わかれることのメリットもあるということ。今回はデメリットを話します。
### デザインツールとコードは違う
pngで書き起こされた画像を見ながら、Vueで落とし込むとなる。それはつまり2度手間になっているという点がある。
* 例、Newのサイトを作ったとする。そこで、検索フォームを追加するとする。
* この場合、検索フォームくらいはデザインで書き起こさずにエンジニアだけで考えて実装したりする。
* この後にデザイン変更があった場合、デザイナーは検索ボックス無しでデザインしたりする。検索ボックスはどこに置くのか？いやそんな話知らないしみたいな

* さっきのニュースの例で、3列の場合ウィンドウがでかい場合どうするのか？
* 4列にする？3列のままにする？そこを、デザイナーに再度確認したりする手間が発生する。
* これがすでに面倒。実際、自分たちも同じことになる。

* vuegg -> 調べてみる
** プロトタイプでデザインしたものが、そのままVueのファイルで書きだしてくれる。

* Framer X
* Vueeggでできない事ができる。ドラッグアンドドロップで画面を作成して、Reactのコンポーネントとして吐き出す。
* その吐き出したコンポーネントをFramerXに再度渡して修正もできる！（ここがvueeggと違う点）

## 作りたいもの
SFC(.vueファイル)が実装、かつデザインできるもの。長期開発、運用に使える動的なデザインを可能なもの。 = FramerXに近いVue版
レスポンシブにも対応させていきたい。

## デモ
Vue Designer
* GoogleChromeで開発者ツールを開いて、修正して、いい感じの見た目になったらそれをエディタに書き込んで～みたいな一連の無駄な流れを改善
* デザイナーが渡してきた画像をコードで似たような見た目になるように開発～みたいなのを改善
GitHubもあるからあとで覗いてみる。 -> tarosukeのふぁぼ

将来的にデザインと実装が同じになればいい。
デザイナーは、GUIでコンポーネントをいじってエンジニアはコードからいじって、お互いにgitで開発できるようになるといい
つまり、今その問題点を解決するツールを作ってるよ～って話

---

> セッション3 (14:40 ~ 15:20)

# 開場 : A

# デザイナーとエンジニアわかりあえてますか？

## コンポーネントベースにすることによる影響
* デザイナー
１つ変えれば、すべて変わる等利点がわかっている場合デザインがしやすい。
習得の難易度が高い。
コンポーネントの設計ベースで開発しなければならない。
* エンジニア
開発工数が少なくなる。開発にかかるコストの大幅軽減。

### デザイナーが大事にしていること
効率化は大事だが、一番大事にしていることはユーザーの反応。
だから、コンポーネントベースの話はとっつきにくい。

### 昔の例
Javaのオブジェクト指向か、今まで通りの構造化言語（C）かみたいな論争が過去にエンジニア感でも繰り広げられていた。
極端な話、それと同じである。
今はオブジェクト指向が広まっているが、どのようにJavaが買ったかというとみんなが慣れたという事が一番でかい。

コンポーネントがいまいち流行らないのは、デザイナーが慣れていないから。

例：
SketchはデザイナーにとってのJava。
C言語はPhotoshop。

慣れない理由は、まだまだツールのサポートが足りてない、わかりづらいという点。

時間が解決するかもしれないが、C言語しかやったことない人にJavaのフレームワークまで使ってアプリを作れというようなもの。
-> めっちゃわかりやすい例え

## デザイナーはエンジニアじゃない
デザイナーはユーザーにすげえ！って言われたい
エンジニアは開発を楽にして工数を削減したい

* そもそも職責が違う

### Design Ops -> 調べてみる

* デザイナーに求めるばかりでなく、エンジニアからサポートしてあげよう！

---

> セッション4 (15:30 ~ 16:10)

# 開場 : B
# 

noteはAngular.jsを使って2013年に開発開始した。
理由
* 複雑なUIに対応できる
* バックエンドはAPI開発に専念できる

課題
* 初期表示速度が遅い。
* Angular.jsの1系を使ってしまっているので、動かないプラグインがある。
* Rubyで書かれているので、Railsの上に載ったフロントエンド設計になってしまっている。
* 負債が多い。コンポーネントの設計など。

表示速度が!%下がるたびに、ECサイトだと離脱率が1%下がる！！！

そこで古リニューアルを決意。
候補で4つ上がった

## Express + Vanilla.js
* フロントエンドの処理が多い
* 開発効率が上がらないので断念

## Vue.jsに決定
活発であり、触っている人が多かった。

### 採用理由
実行速度と開発効率の両立をしている点
* 差分描画などで速度もあり、コンポーネント概念が開発効率を上げている。

学習コストの低さと親しみやすさ
* templateがHTMLと同じで書ける
* デザイナーでも直感で操作できる

ドキュメントの充実度
* 公式ドキュメントがいい感じ

コミュニティの活発度
* Vue.jsの勉強会の多さや開発されているので、しばらくは廃れないという安心感

## Nuxt.jsを触るきっかけ
規約が手に入る（ルール）
* ディレクトリ構成や、ルーティングを自動で生成してくれる点。ルーティングをページごとに作っていくのは地獄。

## 移行手順
Railsサーバーは今まで通り使って、APIサーバーとする。
目標：既存UIを確実に移行させる。大幅なUI / UXの回収は含めない。

## 苦労する点
並行して、現行版の開発はAngularで進んでいる。 = 2重メンテが必要。

## 設計と実装
### 開発環境
* Nuxt.js
* Jest (テストツール)
* ESLint

Angular.js版のコンポーネントを組み替えていく。
今propsのバケツリレーが起きている状況。
* これを解決するVuex + Atmic Design

## AtmicDesignの導入方法
* 全員でページをコンポーネントわけして考えをそろえる。

Nuxt build Analyze とすることで、コンポーネントのデータ使用料を使うことができる

## Polifill.io
UAごとに必要なPolyfillだけまとめて返してくれるもの。
サーバー毎の最適化をしてくれるよ！
nuxt.js.configで呼び出す。

## インフラ
AWS Lambdaをしよう
* AWSなので、使った分だけ金がかかる。
* 構成管理や、デプロイを行う。
Netlifyの金がかかる強化版だと思えばいい

# まとめ
* パスベースで小さく移行するのは有効！
  * パス（URL）
  * 既存の言語やフレーうわーくお制約に縛られない
  * ロールバックが容易。簡単に戻せる。
* デメリット
  * 完全移行まで地獄。並行して開発が進んだり。
* SSRの導入は簡単！
* 環境基盤のサポート規約が非常に強力！
* コストをかけずにモダンな開発環境が手に入る。
* Routerなど、意識したくない部分は全部やってくれるから本来の開発に専念できる。

Nuxt.jsのリリースノートが公開中なので後で見てみる

perlのCatalystも完全移行できたらいいなぁ。。。
-> やっぱり、APIサーバーありきの話になっている。
templateファイルをほんとにそのまま移行できないか？ もう少し調べてみる。
わざわざ.ttファイルで書きだす意味とは？ブラウザでたたけば動くので、移行できるのでは？
-> Vue基盤を少し考え直す。

---

> セッション5 (16:20 ~ 17:00)

# 開場 : B
# https://speakerdeck.com/tsuchikazu/vue-component-test?slide=86

### Componentのテストしてる人～！
* 3割以下
バックエンドAPIサーバーとかで重要なところはテストしてるので、フロントはしてない人が多い。

## 何をテストするの？（テスト観点）
外部からの見え方をテストする

### jsdom
Javascriptで書かれたDOM操作のこと

実ブラウザが必要か、不必要化でテストが変わってきます。

## ライフサイクルのテスト（あまり重要じゃない）
Createとかのライフサイクルって、大したことはしてない。
-> そこをテストしても安心感はあまりない。
ここをテストすることによる安心感は少ないので、ここは自由にいじれるようにするべき。

## Props,Vuex Stateのテスト
主に見た目に直で関わるもの。

## Snapshot Testing
* componentのDOMの差分をテスト見る
* コード修正前のDOMを期待値として、テストする。
  * 変更があれば、1度エラーになる。そこから、新しい差分を正とするかを選択すれば、テストケースが自動で更新される。

## 問題点
IEとかだとやっぱりだめ。
ブラウザ毎に、実行結果が変わってきてしまう。


